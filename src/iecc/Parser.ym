/*******************************************************************************
* Project: IECC (IEC 61131-3 Languages Compiler for Arduino).                  *
* Authors: Paulo H. Torrens <paulotorrens AT gnu DOT org>.                     *
* License: GNU GPLv3+.                                                         *
*                                                                              *
* Language: Bison -> (Modern) Objective-C.                                     *
* Description: Compiler parser file.                                           *
********************************************************************************
* Copyright (C) 2015 - Paulo H. Torrens. All rights reserved.                  *
*                                                                              *
* This program is free software: you can redistribute it and/or modify it      *
* under the terms of the GNU General Public License as published by the Free   *
* Software Foundation, either version 3 of the License, or (at your option)    *
* any later version.                                                           *
*                                                                              *
* This program is distributed in the hope that it will be useful, but WITHOUT  *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for     *
* more details.                                                                *
*                                                                              *
* You should have received a copy of the GNU General Public License along with *
* this program. If not, see <http://www.gnu.org/licenses/>.                    *
*******************************************************************************/
%{
  //
  #import <stdlib.h>
  #import <stdio.h>
  
  //
  extern int yylex(void);
  
  //
  void yyerror(char const *str) {
    /* TODO */
  };
%}

%locations
%token-table
%error-verbose

/* Helper */
%token TOK_INVALID

/* Operators */
%token TOK_SET
%token TOK_DOTDOT

/* Table 2 */
%token TOK_IDENTIFIER
%token TOK_QUALIFIED_IDENTIFIER

/* Table 4 */
%token TOK_PRAGMA

/* Table 5 */
%token TOK_SIGNED_INT_LITERAL
%token TOK_UNSIGNED_INT_LITERAL
%token TOK_GENERIC_INT_LITERAL
%token TOK_REAL_LITERAL
%token TOK_BIT_STR_LITERAL
%token TOK_BOOL_LITERAL

/* Table 6 */
%token TOK_CHAR_LITERAL

/* Tables 8 and 9 */
%token TOK_TIME_LITERAL;

/* Table 10 */
%token TOK_SINT
%token TOK_INT
%token TOK_DINT
%token TOK_LINT
%token TOK_USINT
%token TOK_UINT
%token TOK_UDINT
%token TOK_ULINT
%token TOK_REAL
%token TOK_LREAL
%token TOK_BOOL
%token TOK_BYTE
%token TOK_WORD
%token TOK_DWORD
%token TOK_LWORD
%token TOK_STRING
%token TOK_WSTRING
%token TOK_CHAR
%token TOK_WCHAR
%token TOK_DATE
%token TOK_LDATE
%token TOK_TIME
%token TOK_LTIME
%token TOK_TOD
%token TOK_LTOD
%token TOK_DT
%token TOK_LDT

/* Table 11 */
%token TOK_SIMPLE_TYPENAME
%token TOK_SUBRANGE_TYPENAME
%token TOK_ENUM_TYPENAME
%token TOK_ARRAY_TYPENAME
%token TOK_STRUCT_TYPENAME
%token TOK_STRING_TYPENAME
%token TOK_CLASS_TYPENAME
%token TOK_REF_TYPENAME
%token TOK_INTERFACE_TYPENAME
%token TOK_ENUM_LITERAL
%token TOK_TYPE
%token TOK_END_TYPE
%token TOK_ARRAY
%token TOK_OF
%token TOK_STRUCT
%token TOK_END_STRUCT
%token TOK_OVERLAP

/* Table 16 */
%token TOK_DIRECT_VARIABLE

%%
translation_unit: ;

/* Identifier, taken from table 2 of the standard */
simple_identifier: TOK_IDENTIFIER
                 /* Taken from table 10 */
                 | TOK_SIMPLE_TYPENAME
                 | TOK_SUBRANGE_TYPENAME
                 | TOK_ENUM_TYPENAME
                 | TOK_ARRAY_TYPENAME
                 | TOK_STRUCT_TYPENAME
                 | TOK_STRING_TYPENAME
                 | TOK_CLASS_TYPENAME
                 | TOK_REF_TYPENAME
                 | TOK_INTERFACE_TYPENAME;

qualified_identifier: simple_identifier
                    | TOK_QUALIFIED_IDENTIFIER;

/* Numeric literals, taken from table 5 of the standard */
constant: numeric_literal
        | char_literal
        | time_literal
        | bit_str_literal
        | bool_literal;

numeric_literal: int_literal
               | real_literal;

int_literal: TOK_SIGNED_INT_LITERAL
           | TOK_UNSIGNED_INT_LITERAL
           | TOK_GENERIC_INT_LITERAL;

real_literal: TOK_REAL_LITERAL;

bit_str_literal: TOK_BIT_STR_LITERAL;

bool_literal: TOK_BOOL_LITERAL;

/* Character string literals, taken from table 6 of the standard */
char_literal: TOK_CHAR_LITERAL;

/* Duration, data and time of day literals, taken from tables 8 and 9 of... */
time_literal: TOK_TIME_LITERAL;

/* Elementary data types, taken from table 10 of the standard */
data_type_access: elem_type_name
                | derived_type_access;

elem_type_name: numeric_type_name
              | bit_str_type_name
              | string_type_name
              | date_type_name
              | time_type_name
              | tod_type_name /* (For now) I believe that the standard */
              | dt_type_name; /* forgot to add these rules here... =/  */

elem_type_name_opt: /* empty */
                  | elem_type_name;

numeric_type_name: int_type_name
                 | real_type_name;

int_type_name: sign_int_type_name
             | unsign_int_type_name;

sign_int_type_name: TOK_SINT
                  | TOK_INT
                  | TOK_DINT
                  | TOK_LINT;

unsign_int_type_name: TOK_USINT
                    | TOK_UINT
                    | TOK_UDINT
                    | TOK_ULINT;

real_type_name: TOK_REAL
              | TOK_LREAL;

bit_str_type_name: TOK_BOOL
                 | TOK_BYTE
                 | TOK_WORD
                 | TOK_DWORD
                 | TOK_LWORD;

string_type_name: TOK_STRING string_size
                | TOK_WSTRING string_size
                | TOK_CHAR
                | TOK_WCHAR;

string_size: /* empty */
           | '[' TOK_UNSIGNED_INT_LITERAL ']';

date_type_name: TOK_DATE
              | TOK_LDATE;

time_type_name: TOK_TIME
              | TOK_LTIME;

tod_type_name: TOK_TOD
             | TOK_LTOD;

dt_type_name: TOK_DT
            | TOK_LDT

/* User data types, taken from table 11 of the standard */
derived_type_access: single_elem_type_access
                   | array_type_access
                   | struct_type_access
                   | string_type_access
                   | class_type_access
                   | ref_type_access
                   | interface_type_access;

single_elem_type_access: simple_type_access
                       | subrange_type_access
                       | enum_type_access;

simple_type_access: TOK_SIMPLE_TYPENAME;

subrange_type_access: TOK_SUBRANGE_TYPENAME;

enum_type_access: TOK_ENUM_TYPENAME;

array_type_access: TOK_ARRAY_TYPENAME;

struct_type_access: TOK_STRUCT_TYPENAME;

string_type_access: TOK_STRING_TYPENAME;

class_type_access: TOK_CLASS_TYPENAME;

ref_type_access: TOK_REF_TYPENAME;

interface_type_access: TOK_INTERFACE_TYPENAME;

data_type_decl: TOK_TYPE type_decl_list TOK_END_TYPE;

type_decl_list: type_decl ";"
              | type_decl_list type_decl ";";

type_decl: simple_type_decl
         | subrange_type_decl
         | enum_type_decl
         | array_type_decl
         | struct_type_decl
         | str_type_decl
         | ref_type_decl;

simple_type_decl: simple_identifier ':' simple_spec_init;

simple_spec_init: simple_spec simple_set_value;

simple_spec: elem_type_name
           | simple_type_access;

simple_set_value: /* empty */
                | TOK_SET constant_expr;

subrange_type_decl: simple_identifier ':' subrange_spec_init;

subrange_spec_init: subrange_spec subrange_set_value;

subrange_spec: int_type_name '(' subrange ')'
             | subrange_type_access;

subrange: constant_expr TOK_DOTDOT constant_expr;

subrange_set_value: /* empty */
                  | TOK_SET TOK_SIGNED_INT_LITERAL;

enum_type_decl: simple_identifier ':' enum_type_decl2;

enum_type_decl2: elem_type_name_opt named_spec_init
               | enum_spec_init;

named_spec_init: '(' enum_value_spec_list ')' named_set_value;

named_set_value: /* empty */
               | TOK_SET enum_value;

enum_value_spec_list: enum_value_spec
                    | enum_value_spec_list ',' enum_value_spec;

enum_spec_init: enum_spec_init_type named_set_value;

enum_spec_init_type: '(' enum_value_spec_list ')'
                   | enum_type_access;

enum_value_spec: simple_identifier enum_value_spec_set_value;

enum_value_spec_set_value: /* empty */
                         | TOK_SET int_literal
                         | TOK_SET constant_expr;

enum_value: simple_identifier
          | TOK_ENUM_LITERAL;

array_type_decl: simple_identifier ':' array_spec_init;

array_spec_init: array_spec array_set_value;

array_set_value: /* empty */
               | TOK_SET array_init;

array_spec: array_type_access
          | TOK_ARRAY '[' subrange_list ']' TOK_OF data_type_access;

subrange_list: subrange
             | subrange_list ',' subrange;

array_init: '[' array_elem_init_list ']';

array_elem_init_list: array_elem_init
                    | array_elem_init_list ',' array_elem_init;

array_elem_init: array_elem_init_value
               | TOK_UNSIGNED_INT_LITERAL '(' array_elem_init_value_opt ')';

array_elem_init_value: constant_expr
                     | enum_value
                     | struct_init
                     | array_init;

array_elem_init_value_opt: /* empty */
                         | array_elem_init_value;

struct_type_decl: simple_identifier ':' struct_spec;

struct_spec: struct_decl
           | struct_spec_init;

struct_spec_init: struct_type_access struct_set_value;

struct_set_value: /* empty */
                | TOK_SET struct_init;

struct_decl: TOK_STRUCT struct_elem_decl_list TOK_END_STRUCT
           | TOK_STRUCT TOK_OVERLAP struct_elem_decl_list TOK_END_STRUCT;

struct_elem_decl_list: struct_elem_decl ';'
                     | struct_elem_decl_list struct_elem_decl ';';

struct_elem_decl: struct_elem_decl2 ':' struct_elem_decl3;

struct_elem_decl2: simple_identifier
                 | simple_identifier located_at
                 | simple_identifier located_at multibit_part_access;

struct_elem_decl3: simple_spec_init
                 | subrange_spec_init
                 | enum_spec_init
                 | array_spec_init
                 | struct_spec_init;

struct_init: '(' struct_elem_init_list ')';

struct_elem_init_list: struct_elem_init
                     | struct_elem_init_list ',' struct_elem_init;

struct_elem_init: simple_identifier struct_elem_set_value;

struct_elem_set_value: TOK_SET constant_expr
                     | TOK_SET enum_value
                     | TOK_SET array_init
                     | TOK_SET struct_init
                     | TOK_SET ref_value;

str_type_decl: simple_identifier ':' string_type_name string_set_value;

string_set_value: /* empty */
                | TOK_SET char_str;











/* Directly represented variables, taken from table 16 of the standard */
direct_variable: TOK_DIRECT_VARIABLE;







constant_expr:;

%%

/**
 * Temporary main function. Just lexes stdin and show which
 * tokens were found. :)
 */
int main() {
  int x;
  extern int yyleng;
  extern int yylineno;
  extern int yycolumn;
  extern char *yytext;
  
  do {
    x = yylex();
    printf("%d:%02d-%02d:", yylineno, yycolumn, yycolumn + x ? yyleng : 0);
    if(x >= 0x80) {
      printf("%-20s %s", yytname[x - 255], yytext);
    } else {
      if(x) {
        printf("'%c'", x);
      } else {
        printf("EOF");
      };
    };
    printf("\n");
  } while(x);
  
  return EXIT_SUCCESS;
};
