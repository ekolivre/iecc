/*******************************************************************************
* Project: IECC (IEC 61131-3 Languages Compiler for Arduino).                  *
* Authors: Paulo H. Torrens <paulotorrens AT gnu DOT org>.                     *
* License: GNU GPLv3+.                                                         *
*                                                                              *
* Language: Bison -> (Legacy) Objective-C.                                     *
* Description: Compiler parser file. It handles the grammar of the common base *
*   and of all the programming languages supported.                            *
********************************************************************************
* Copyright (C) 2015 - Paulo H. Torrens. All rights reserved.                  *
*                                                                              *
* This program is free software: you can redistribute it and/or modify it      *
* under the terms of the GNU General Public License as published by the Free   *
* Software Foundation, either version 3 of the License, or (at your option)    *
* any later version.                                                           *
*                                                                              *
* This program is distributed in the hope that it will be useful, but WITHOUT  *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for     *
* more details.                                                                *
*                                                                              *
* You should have received a copy of the GNU General Public License along with *
* this program. If not, see <http://www.gnu.org/licenses/>.                    *
*******************************************************************************/
/*
  RATIONALE:
  
  I've tried to keep note of every part of the standard where I find each piece,
  so anyone can easely look into it if necessary, but (please don't get mad, IEC
  guys) it's quite hard and it's a bit messy. This parser makes a lot of type
  dependent lookups, which means we have to keep giving back information to the
  lexer all the time (e.g., as soon as a type or a variable is about to be
  defined), the good ol' "The Lexer Hack". So you will need to carefully need
  study the lexer too to understand this. If you have a copy of the standard
  you'll notice that I had to change a lot of tokens to get the correct
  behaviour without any ambiguities, typechecking it during parsing.
  
  So, if you find the grammar confusing, don't blame me! :(
*/
%code requires {
  // Default includes
  #import "IECCBinder.h"
  #import "NSNumber+IECC.h"
  
  // So, flex needs the binder to keep types and variables
  #define YY_DECL int yylex(IECCBinder *binder)
  extern YY_DECL;
  
  // We don't wanna define this no flex
  #if YYBISON
    // Pass our binder with ourselves!
    #define yylex() yylex(binder)
  #endif
  
  // Duck typing FTW! ;)
  #define YYSTYPE id
}

%{
  //
  #import <stdlib.h>
  #import <stdio.h>
  #import "IECCBinder.h"
  #import "IECCDataType.h"
  #define YYDEBUG 1
  
  //
  void yyerror(IECCBinder *binder, char const *str) {
    
    extern int yyleng;
    extern int yycolumn;
    extern int yylineno;
    
    printf("At %d:%d: %s\n", yylineno, yycolumn - yyleng, str);
  };
%}

%debug
%locations
%glr-parser
%token-table
%error-verbose

/* */
%parse-param {IECCBinder *binder}

/* Helper */
%token TOK_TODO
%token TOK_INVALID

/* Typenames */
%token TOK_SIMPLE_TYPENAME "typename"
%token TOK_SUBRANGE_TYPENAME
%token TOK_ENUM_TYPENAME
%token TOK_ARRAY_TYPENAME
%token TOK_STRUCT_TYPENAME
%token TOK_STRING_TYPENAME
%token TOK_CLASS_TYPENAME
%token TOK_REF_TYPENAME
%token TOK_INTERFACE_TYPENAME

/* Table 2 */
%token TOK_IDENTIFIER "unbound identifier"

/* Table 5 */
%token TOK_SIGNED_INT_LITERAL
%token TOK_UNSIGNED_INT_LITERAL
%token TOK_GENERIC_INT_LITERAL
%token TOK_REAL_LITERAL
%token TOK_BIT_STR_LITERAL
%token TOK_BOOL_LITERAL

/* Table 6 */
%token TOK_TYPED_CHAR_LITERAL
%token TOK_UNTYPED_CHAR_LITERAL_S
%token TOK_UNTYPED_CHAR_LITERAL_D

/* Tables 8 and 9 */
%token TOK_TIME_LITERAL;

/* Table 10 */
%token TOK_SINT
%token TOK_INT
%token TOK_DINT
%token TOK_LINT
%token TOK_USINT
%token TOK_UINT
%token TOK_UDINT
%token TOK_ULINT
%token TOK_REAL
%token TOK_LREAL
%token TOK_BOOL
%token TOK_BYTE
%token TOK_WORD
%token TOK_DWORD
%token TOK_LWORD
%token TOK_STRING
%token TOK_WSTRING
%token TOK_CHAR
%token TOK_WCHAR
%token TOK_DATE
%token TOK_LDATE
%token TOK_TIME
%token TOK_LTIME
%token TOK_TOD
%token TOK_LTOD
%token TOK_DT
%token TOK_LDT

/* Table 11 */
%token TOK_ENUM_LITERAL "enum literal"
%token TOK_TYPE
%token TOK_END_TYPE
%token TOK_ARRAY
%token TOK_OF
%token TOK_STRUCT
%token TOK_END_STRUCT
%token TOK_OVERLAP

/* Table 12 */
%token TOK_REF_TO
%token TOK_REF
%token TOK_NULL

/* Tables 13 and 14 */
%token TOK_THIS
%token TOK_VAR
%token TOK_VAR_INPUT
%token TOK_VAR_OUTPUT
%token TOK_VAR_IN_OUT
%token TOK_VAR_TEMP
%token TOK_VAR_EXTERNAL
%token TOK_VAR_GLOBAL
%token TOK_RETAIN
%token TOK_NON_RETAIN
%token TOK_END_VAR
%token TOK_R_EDGE
%token TOK_F_EDGE
%token TOK_CONSTANT
%token TOK_AT

/* Table 16 */
%token TOK_DIRECT_VARIABLE
%token TOK_DIRECT_VARIABLE_PART;

/* Table 19 */
%token TOK_FUNCTION
%token TOK_END_FUNCTION

/* Tables 40 and 41 */
%token TOK_FUNCTION_BLOCK
%token TOK_END_FUNCTION_BLOCK
%token TOK_FINAL
%token TOK_ABSTRACT
%token TOK_EXTENDS
%token TOK_IMPLEMENTS
%token TOK_METHOD
%token TOK_END_METHOD
%token TOK_OVERRIDE

/* Table 47 */
%token TOK_PROGRAM
%token TOK_END_PROGRAM
%token TOK_VAR_ACCESS

/* Tables 48 and 50 */
%token TOK_CLASS
%token TOK_END_CLASS
%token TOK_INTERFACE
%token TOK_END_INTERFACE
%token TOK_PUBLIC
%token TOK_PROTECTED
%token TOK_PRIVATE
%token TOK_INTERNAL

/* Table 62 */
%token TOK_CONFIGURATION
%token TOK_END_CONFIGURATION
%token TOK_RESOURCE
%token TOK_END_RESOURCE
%token TOK_ON
%token TOK_READ_WRITE
%token TOK_READ_ONLY
%token TOK_TASK
%token TOK_SINGLE
%token TOK_INTERVAL
%token TOK_PRIORITY
%token TOK_WITH
%token TOK_VAR_CONFIG

/* Table 64 */
%token TOK_NAMESPACE
%token TOK_END_NAMESPACE
%token TOK_USING

/* Placeholders! TODO! */
%token TOK_LANG_LD
%token TOK_LANG_FB
%token TOK_LANG_IL
%token TOK_LANG_ST
%token TOK_LANG_SFC
%token TOK_LANG_C

/* Operators... */
%token TOK_SET
%token TOK_DOTDOT
%token TOK_FAT_ARROW
%token TOK_OR
%token TOK_XOR
%token TOK_AND
%token TOK_EQUAL
%token TOK_DIFF
%token TOK_LESS
%token TOK_MORE
%token TOK_LESS_EQ
%token TOK_MORE_EQ
%token TOK_PLUS
%token TOK_MINUS
%token TOK_TIMES
%token TOK_DIV
%token TOK_MOD
%token TOK_POWER
%token TOK_NOT

/* Operator precedence... */
%left TOK_OR
%left TOK_XOR
%left TOK_AND
%left TOK_EQUAL TOK_DIFF
%left TOK_LESS TOK_MORE TOK_LESS_EQ TOK_MORE_EQ
%left TOK_PLUS TOK_MINUS
%left TOK_TIMES TOK_DIV TOK_MOD
%left TOK_POWER
%left TOK_NOT TOK_UNARY_MINUS TOK_UNARY_PLUS

%%
/******************************************************************************/
/* Base common language. All sublanguages (ST, IL, LD, etc) will be placed in */
/* function bodies defined within this grammar.                               */
/******************************************************************************/
/*

*/
translation_unit: POU_decl;

/* Identifier, taken from table 2 of the standard */
simple_identifier: TOK_IDENTIFIER {
                   $$ = $1;
                 };

qualified_identifier: path simple_identifier;

path: /* empty */
    | path namespace_name '.';

namespace_name: simple_identifier;

/* Numeric literals, taken from table 5 of the standard */
constant: numeric_literal
        | char_literal
        | time_literal
        | bit_str_literal
        | bool_literal;

numeric_literal: int_literal {
                 $$ = $1;
               }
               | real_literal {
                 $$ = $1;
               };

int_literal: signed_int {
             $$ = $1;
           }
           | TOK_GENERIC_INT_LITERAL {
             $$ = $1;
           };

signed_int: TOK_SIGNED_INT_LITERAL {
            $$ = $1;
          }
          | TOK_UNSIGNED_INT_LITERAL {
            $$ = $1;
          };

real_literal: TOK_REAL_LITERAL {
                $$ = $1;
              };

bit_str_literal: TOK_BIT_STR_LITERAL;

bool_literal: TOK_BOOL_LITERAL;

/* Character string literals, taken from table 6 of the standard */
char_literal: char_str
            | TOK_TYPED_CHAR_LITERAL;

s_byte_char_str: TOK_UNTYPED_CHAR_LITERAL_S;

d_byte_char_str: TOK_UNTYPED_CHAR_LITERAL_D;

char_str: s_byte_char_str
        | d_byte_char_str;

/* Duration, data and time of day literals, taken from tables 8 and 9 of... */
time_literal: TOK_TIME_LITERAL;

/* Elementary data types, taken from table 10 of the standard */
data_type_access: elem_type_name {
                  $$ = $1;
                }
                | derived_type_access {
                  $$ = $1;
                };

elem_type_name: numeric_type_name {
                $$ = $1;
              }
              | bit_str_type_name {
                $$ = $1;
              }
              | string_type_name {
                $$ = $1;
              }
              | date_type_name {
                $$ = $1;
              }
              | time_type_name {
                $$ = $1;
              }
              | tod_type_name { /* FIXME! */
                $$ = $1;        /* (For now) I believe that the standard */
              }                 /* forgot to add these rules here... =/  */
              | dt_type_name {  /* FIXME! */
                $$ = $1;        /* Ditto. */
              };

elem_type_name_opt: /* empty */ {
                    $$ = nil;
                  }
                  | elem_type_name {
                    $$ = $1;
                  };

numeric_type_name: int_type_name {
                   $$ = $1;
                 }
                 | real_type_name {
                   $$ = $1;
                 };

int_type_name: sign_int_type_name {
               $$ = $1;
             }
             | unsign_int_type_name {
               $$ = $1;
             };

sign_int_type_name: TOK_SINT {
                    $$ = IECCSInt.new;
                  }
                  | TOK_INT {
                    $$ = IECCInt.new;
                  }
                  | TOK_DINT {
                    $$ = IECCDInt.new;
                  }
                  | TOK_LINT {
                    $$ = IECCLInt.new;
                  };

unsign_int_type_name: TOK_USINT {
                      $$ = IECCUSInt.new;
                    }
                    | TOK_UINT {
                      $$ = IECCUInt.new;
                    }
                    | TOK_UDINT {
                      $$ = IECCUDInt.new;
                    }
                    | TOK_ULINT {
                      $$ = IECCULInt.new;
                    };

real_type_name: TOK_REAL {
                $$ = IECCReal.new;
              }
              | TOK_LREAL {
                $$ = IECCLReal.new;
              };

bit_str_type_name: TOK_BOOL {
                   $$ = IECCBool.new;
                 }
                 | TOK_BYTE {
                   $$ = IECCByte.new;
                 }
                 | TOK_WORD {
                   $$ = IECCWord.new;
                 }
                 | TOK_DWORD {
                   $$ = IECCDWord.new;
                 }
                 | TOK_LWORD {
                   $$ = IECCLWord.new;
                 };

string_type_name: TOK_STRING string_size {
                  $$ = IECCString.new;
                  [$$ setStringSize: $2];
                }
                | TOK_WSTRING string_size {
                  $$ = IECCWString.new;
                  [$$ setStringSize: $2];
                }
                | TOK_CHAR {
                  $$ = IECCChar.new;
                }
                | TOK_WCHAR {
                  $$ = IECCWChar.new;
                };

string_size: /* empty */ {
             $$ = nil;
           }
           | '[' TOK_UNSIGNED_INT_LITERAL ']' {
             $$ = $2;
           };

date_type_name: TOK_DATE {
                $$ = IECCDate.new;
              };

time_type_name: TOK_TIME {
                $$ = IECCTime.new;
              }
              | TOK_LTIME {
                $$ = IECCLTime.new;
              };

tod_type_name: TOK_TOD {
               $$ = IECCTimeOfDay.new;
             }
             | TOK_LTOD {
               $$ = IECCLTimeOfDay.new;
             }

dt_type_name: TOK_DT {
              $$ = IECCDateAndTime.new;
            }
            | TOK_LDT {
              $$ = IECCDateAndTime.new;
            };

/* User data types, taken from table 11 of the standard */
derived_type_access: single_elem_type_access
                   | array_type_access
                   | struct_type_access
                   | string_type_access
                   | class_type_access
                   | ref_type_access
                   | interface_type_access;

single_elem_type_access: simple_type_access
                       | subrange_type_access
                       | enum_type_access;

simple_type_access: TOK_SIMPLE_TYPENAME {
                    $$ = $1;
                  }
                  | TOK_STRING_TYPENAME {
                    /* Strings count as simple types! */
                    $$ = $1;
                  };

subrange_type_access: TOK_SUBRANGE_TYPENAME {
                      $$ = $1;
                    };

enum_type_access: TOK_ENUM_TYPENAME {
                    $$ = $1;
                  };

array_type_access: TOK_ARRAY_TYPENAME;

struct_type_access: TOK_STRUCT_TYPENAME;

string_type_access: TOK_STRING_TYPENAME {
                    $$ = $1;
                  };

class_type_access: TOK_CLASS_TYPENAME;

ref_type_access: TOK_REF_TYPENAME;

interface_type_access: TOK_INTERFACE_TYPENAME;

data_type_decl: TOK_TYPE type_decl_list TOK_END_TYPE;

type_decl_list: type_decl ';'
              | type_decl_list type_decl ';';

type_decl: simple_type_decl %dprec 50
         | subrange_type_decl
         | enum_type_decl
         | array_type_decl
         | struct_type_decl
         | str_type_decl %dprec 10
         | ref_type_decl;

simple_type_decl: simple_identifier ':' simple_spec_init {
                  // Simple type declaration
                  $$ = [binder
                    declareType: $1
                             as: [$3 objectAtIndex: 0] // TODO: default value
                         atLine: @1.first_line
                  ];
                };

simple_spec_init: simple_spec simple_set_value {
                  $$ = @[$1, $2];
                };

simple_spec: elem_type_name {
             $$ = $1;
           }
           | simple_type_access {
             $$ = $1;
           };

simple_set_value: /* empty */ {
                  $$ = [NSNull null];
                }
                | TOK_SET constant_expr {
                  if($2) {
                    $$ = $2;
                  } else {
                    // TODO: warn about expression error!
                    $$ = [NSNull null];
                  };
                };

subrange_type_decl: simple_identifier ':' subrange_spec_init {
                    // Subrange type declaration
                    $$ = [binder
                      declareType: $1
                               as: [$3 objectAtIndex: 0] // TODO: default value
                           atLine: @1.first_line
                    ];
                  };

subrange_spec_init: subrange_spec subrange_set_value {
                    // TODO: check if value is on range!
                    $$ = @[$1, $2];
                  };

subrange_spec: int_type_name '(' subrange ')' {
               $$ = [IECCSubrange subrangeWithRange: $3];
             }
             | subrange_type_access {
               $$ = $1;
             };

subrange: constant_expr TOK_DOTDOT constant_expr {
            // TODO: check if both bounds are integers!
            $$ = @[$1, $3];
          };

subrange_set_value: /* empty */ {
                    $$ = [NSNull null];
                  }
                  | TOK_SET signed_int {
                    $$ = $2;
                  };

enum_type_decl: simple_identifier ':' enum_type_decl2 {
                // Enum or "type with named value" type declaration
                $$ = [binder
                  declareType: $1
                           as: [$3 objectAtIndex: 0] // TODO: default value
                       atLine: @1.first_line
                ];
              };

enum_type_decl2: elem_type_name_opt named_spec_init /* %dprec 10 */ {
                 // TODO
                 $$ = $2;
               }
               | enum_spec_init /* %dprec 50 */ {
                 $$ = $1;
               };

named_spec_init: named_spec_init_type named_set_value {
                 assert("Internal compiler error." && $1 && $2);
                 $$ = @[$1, $2];
               };

named_spec_init_type: enter_enum enum_value_spec_list leave_enum {
                      // Pass on our returned enum up
                      $$ = $3;
                    };

named_set_value: /* empty */ {
                 $$ = [NSNull null];
               }
               | TOK_SET enum_value {
                 $$ = $2;
               };

enum_value_spec_list: enum_value_spec
                    | enum_value_spec_list ',' enum_value_spec;

enum_spec_init: enum_spec_init_type named_set_value {
                assert("Internal compiler error." && $1 && $2);
                $$ = @[$1, $2];
              };

/*
  We ignore plain enum enumerations here, as they are a subset of types with
  named elements. For a better explanation why, please check the documentation
  for the IECCEnum class. This rule will only match when a type alias is made.
*/
enum_spec_init_type: /*enter_enum enum_value_list leave_enum {
                     // Pass on our returned enum up
                     $$ = $3;
                   }
                   | */ enum_type_access {
                     // We are just making a type alias
                     $$ = $1;
                   };

/* Used for plain enums, not types with named values, we don't set values! */
enum_value_list: simple_identifier
               | enum_value_list ',' simple_identifier;

enter_enum: '(' {
            [binder enterEnum];
          };

leave_enum: ')' {
            $$ = [binder leaveEnum];
          };

enum_value_spec: simple_identifier enum_value_spec_set_value {
                 // We have to bind them immediately!
                 [binder setEnumValue: $1 as: $2];
               };

enum_value_spec_set_value: /* empty */ {
                           $$ = [NSNull null];
                         }
                         | TOK_SET constant_expr {
                           if($2) {
                             $$ = $2;
                           } else {
                             // TODO: handle expression error
                             // Acts as if we hadn't set a value
                             $$ = [NSNull null];
                           };
                         };

enum_value: TOK_ENUM_LITERAL;

array_type_decl: simple_identifier ':' array_spec_init;

array_spec_init: array_spec array_set_value;

array_set_value: /* empty */
               | TOK_SET array_init;

array_spec: array_type_access
          | TOK_ARRAY '[' subrange_list ']' TOK_OF data_type_access;

subrange_list: subrange
             | subrange_list ',' subrange;

array_init: '[' array_elem_init_list ']';

array_elem_init_list: array_elem_init
                    | array_elem_init_list ',' array_elem_init;

array_elem_init: array_elem_init_value
               | TOK_UNSIGNED_INT_LITERAL '(' array_elem_init_value_opt ')';

array_elem_init_value: constant_expr
                     | enum_value
                     | struct_init
                     | array_init;

array_elem_init_value_opt: /* empty */
                         | array_elem_init_value;

struct_type_decl: simple_identifier ':' struct_spec;

struct_spec: struct_decl
           | struct_spec_init;

struct_spec_init: struct_type_access struct_set_value;

struct_set_value: /* empty */
                | TOK_SET struct_init;

struct_decl: TOK_STRUCT struct_elem_decl_list TOK_END_STRUCT
           | TOK_STRUCT TOK_OVERLAP struct_elem_decl_list TOK_END_STRUCT;

struct_elem_decl_list: struct_elem_decl ';'
                     | struct_elem_decl_list struct_elem_decl ';';

struct_elem_decl: struct_elem_decl2 ':' struct_elem_decl3;

struct_elem_decl2: simple_identifier
                 | simple_identifier located_at
                 | simple_identifier located_at multibit_part_access;

struct_elem_decl3: simple_spec_init
                 | subrange_spec_init
                 | enum_spec_init
                 | array_spec_init
                 | struct_spec_init;

struct_elem_name: simple_identifier;

struct_init: '(' struct_elem_init_list ')';

struct_elem_init_list: struct_elem_init
                     | struct_elem_init_list ',' struct_elem_init;

struct_elem_init: simple_identifier struct_elem_set_value;

struct_elem_set_value: TOK_SET constant_expr
                     | TOK_SET enum_value
                     | TOK_SET array_init
                     | TOK_SET struct_init
                     | TOK_SET ref_value;

str_type_decl: simple_identifier ':' string_type_name string_set_value {
               // String type declaration
               $$ = [binder
                 declareType: $1
                          as: $3 // TODO: default value
                      atLine: @1.first_line
               ];
             };

string_set_value: /* empty */
                | TOK_SET char_str;

/* References, taken from table 12 of the standard */
ref_type_decl: simple_identifier ':' ref_spec_init;

ref_spec_init: ref_spec ref_set_value;

ref_set_value: /* empty */
             | TOK_SET ref_value;

ref_spec: ref_to_list data_type_access;

ref_to_list: TOK_REF_TO
           | ref_to_list TOK_REF_TO;

ref_value: ref_addr
         | TOK_NULL;

ref_addr: TOK_REF '(' ref_addr2 ')';

ref_addr2: symbolic_variable
         | fb_instance_name
         | class_instance_name;

/* oh God... :( */

ref_assign: simple_identifier TOK_SET simple_identifier
          | simple_identifier TOK_SET ref_deref
          | ref_value;

ref_deref: simple_identifier carret_list;

carret_list: '^'
           | carret_list '^';

carret_list_opt: /* empty */
               | carret_list;

/* Declaration and initialization of variables, taken from tables 13 and 14 */
variable: direct_variable
        | symbolic_variable;

symbolic_variable: symbolic_variable_path symbolic_variable_access;

symbolic_variable_access: var_access
                        | multi_elem_var;

symbolic_variable_path: /* empty */
                      | TOK_THIS '.'
                      | path;

var_access: simple_identifier /* oh God... :( */
          | ref_deref;

multi_elem_var: var_access multi_elem_var2_list;

multi_elem_var2_list: multi_elem_var2
                    | multi_elem_var2_list multi_elem_var2;

multi_elem_var2: subscript_list
               | struct_variable;

subscript_list: '[' subscript_list2 ']';

subscript_list2: subscript
               | subscript_list2 ',' subscript;

subscript: expression;

struct_variable: '.' struct_elem_select;

struct_elem_select: var_access; /* WHY, IEC, WHY?!?! */

input_decls: TOK_VAR_INPUT retain_non_retain_opt input_decl_list TOK_END_VAR;

retain_non_retain: TOK_RETAIN
                 | TOK_NON_RETAIN;

retain_non_retain_opt: /* empty */
                     | retain_non_retain;

input_decl_list: /* empty */
               | input_decl_list input_decl ';';

input_decl: var_decl_init
          | edge_decl
          | array_conform_decl;

edge_decl: variable_list ':' TOK_BOOL TOK_R_EDGE
         | variable_list ':' TOK_BOOL TOK_F_EDGE;
         
variable_list: variable_name
             | variable_list ',' variable_name;

variable_name: simple_identifier;

var_decl_init: variable_list ':' var_decl_init2
             | array_var_decl_init
             | struct_var_decl_init
             | fb_decl_init
             | interface_spec_init;

var_decl_init2: simple_spec_init
              | str_var_decl
              | ref_spec_init;

ref_var_decl: variable_list ':' ref_spec;

interface_var_decl: variable_list ':' interface_type_access;

array_var_decl_init: variable_list ':' array_spec_init;

array_conformand: TOK_ARRAY '[' star_list ']' TOK_OF data_type_access;

star_list: TOK_TIMES
         | star_list ',' TOK_TIMES;

star_list_opt: /* empty */
             | star_list;

array_conform_decl: variable_list ':' array_conformand;

struct_var_decl_init: variable_list ':' struct_spec_init;

fb_decl_no_init: fb_name_list ':' fb_type_access;

fb_name_list: simple_identifier
            | fb_name_list ',' simple_identifier;

fb_decl_init: fb_decl_no_init fb_decl_set_value;

fb_decl_set_value: /* empty */
                 | TOK_SET struct_init;

fb_instance_name: path fb_name carret_list_opt;

fb_name: simple_identifier;

output_decls: TOK_VAR_OUTPUT retain_non_retain_opt output_decl_list TOK_END_VAR;

output_decl_list: /* empty */
                | output_decl_list output_decl ';';

output_decl: var_decl_init
           | array_conform_decl;

in_out_decls: TOK_VAR_IN_OUT in_out_var_decl_list TOK_END_VAR;

in_out_var_decl_list: /* empty */
                    | in_out_var_decl_list in_out_var_decl ';';

in_out_var_decl: var_decl
               | array_conform_decl
               | fb_decl_no_init;

var_decl: variable_list ':' var_decl2;

var_decl2: simple_spec
         | str_var_decl
         | array_var_decl
         | struct_var_decl;

array_var_decl: variable_list ':' array_spec;

struct_var_decl: variable_list ':' struct_type_access;

var_decls: TOK_VAR constant_opt access_spec_opt var_decl_init_list TOK_END_VAR;

constant_opt: /* empty */
            | TOK_CONSTANT;

access_spec_opt: /* empty */
               | access_spec;

var_decl_init_list: /* empty */
                  | var_decl_init_list var_decl_init ';';

retain_var_decls: TOK_VAR TOK_RETAIN access_spec_opt var_decl_init_list
                  TOK_END_VAR;

loc_var_decls: TOK_VAR constant_retain_non_retain_opt loc_var_decl_list
               TOK_END_VAR;

constant_retain_non_retain_opt: TOK_CONSTANT
                              | retain_non_retain_opt;

loc_var_decl_list: /* empty */
                 | loc_var_decl_list loc_var_decl ';';

loc_var_decl: variable_name_opt located_at ':' loc_var_spec_init;

variable_name_opt: /* empty */
                 | variable_name;

temp_var_decls: TOK_VAR_TEMP temp_var_decls2_list TOK_END_VAR;

temp_var_decls2_list: /* empty */
                    | temp_var_decls2_list temp_var_decls2 ';';

temp_var_decls2: var_decl
               | ref_var_decl
               | interface_var_decl;

external_var_decls: TOK_VAR_EXTERNAL constant_opt external_decl_list
                    TOK_END_VAR;

external_decl_list: /* empty */
                  | external_decl_list external_decl ';';

external_decl: global_var_name ':' external_decl2;

external_decl2: simple_spec
              | array_spec
              | struct_type_access
              | fb_type_access
              | ref_type_access;

global_var_name: simple_identifier;

global_var_decls: TOK_VAR_GLOBAL constant_retain_opt global_var_decl_list
                  TOK_END_VAR;

constant_retain_opt: /* empty */
                   | TOK_CONSTANT
                   | TOK_RETAIN;

global_var_decl_list: /* empty */
                    | global_var_decl_list global_var_decl ';';

global_var_decl: global_var_spec ':' global_var_decl2;

global_var_decl2: loc_var_spec_init
                | fb_type_access;

global_var_spec: global_var_spec2
               | global_var_spec3;

global_var_spec2: global_var_name_list;

global_var_name_list: global_var_name
                    | global_var_name_list ',' global_var_name;

global_var_spec3: global_var_name located_at;

loc_var_spec_init: simple_spec_init
                 | array_spec_init
                 | struct_spec_init
                 | s_byte_str_spec
                 | d_byte_str_spec;

located_at: TOK_AT direct_variable;

str_var_decl: s_byte_str_var_decl
            | d_byte_str_var_decl;

s_byte_str_var_decl: variable_list ':' s_byte_str_spec;

s_byte_str_spec: TOK_STRING string_size s_byte_str_set_value;

s_byte_str_set_value: /* empty */
                    | TOK_SET s_byte_char_str;

d_byte_str_var_decl: variable_list ':' d_byte_str_spec;

d_byte_str_spec: TOK_WSTRING string_size d_byte_str_set_value;

d_byte_str_set_value: /* empty */
                    | TOK_SET d_byte_char_str;

loc_partly_var_decl: TOK_VAR retain_non_retain_opt loc_partly_var_list

loc_partly_var_list: /* empty */
                   | loc_partly_var_list loc_partly_var;

loc_partly_var: variable_name TOK_AT TOK_DIRECT_VARIABLE_PART ':' var_spec ';';

var_spec: simple_spec
        | array_spec
        | struct_type_access
        | var_spec_str_spec;

var_spec_str_spec: TOK_STRING string_size
                 | TOK_WSTRING string_size;

/* Directly represented variables, taken from table 16 of the standard */
direct_variable: TOK_DIRECT_VARIABLE
               | TOK_DIRECT_VARIABLE_PART;

/* Function declarations, taken from table 19 of the standard */
func_name: std_func_name
         | derived_func_name;

func_access: path func_name;

std_func_name: TOK_TODO;

derived_func_name: simple_identifier;

func_decl: TOK_FUNCTION derived_func_name func_data_type_access
           using_directive_list func_decl_var_decl_list func_body
           TOK_END_FUNCTION;

func_data_type_access: /* empty */
                     | ':' data_type_access;

using_directive_list: /* empty */
                    | using_directive_list using_directive;

func_decl_var_decl_list: /* empty */
                       | func_decl_var_decl_list func_decl_var_decl;

func_decl_var_decl: io_var_decls
                  | func_var_decls
                  | temp_var_decls;

io_var_decls: input_decls
            | output_decls
            | in_out_decls;

func_var_decls: external_var_decls
              | var_decls;

func_body: ladder_diagram
         | fb_diagram
         | instruction_list
         | stmt_list
         | other_languages;

/* Function block type and instance declarations, taken from tables 40 and 41 */
fb_type_name: std_fb_name
            | derived_fb_name;

fb_type_access: path fb_type_name;

std_fb_name: TOK_TODO;

derived_fb_name: simple_identifier;

fb_decl: TOK_FUNCTION_BLOCK final_abstract_opt derived_fb_name
         using_directive_list fb_decl_extends fb_decl_implements
         fb_decl_decl_list method_decl_list fb_body_opt TOK_END_FUNCTION_BLOCK;

fb_body_opt: /* empty */
           | fb_body;

method_decl_list: /* empty */
                | method_decl_list method_decl;

final_abstract_opt: /* empty */
                  | TOK_FINAL
                  | TOK_ABSTRACT;

fb_decl_extends: /* empty */
               | TOK_EXTENDS fb_type_access
               | TOK_EXTENDS class_type_access;

fb_decl_implements: /* empty */
                  | TOK_IMPLEMENTS interface_name_list;

fb_decl_decl_list: /* empty */
                 | fb_decl_decl_list fb_decl_decl;

fb_decl_decl: fb_io_var_decls
            | func_var_decls
            | temp_var_decls
            | other_var_decls;

fb_io_var_decls: fb_input_decls
               | fb_output_decls
               | in_out_decls;

fb_input_decls: TOK_VAR_INPUT retain_non_retain_opt fb_input_decl_list
                TOK_END_VAR;

fb_input_decl_list: /* empty */
                  | fb_input_decl_list fb_input_decl ';';

fb_input_decl: var_decl_init
             | edge_decl
             | array_conform_decl;

fb_output_decls: TOK_VAR_OUTPUT retain_non_retain_opt fb_output_decl_list
                 TOK_END_VAR;

fb_output_decl_list: /* empty */
                   | fb_output_decl_list fb_output_decl ';';

fb_output_decl: var_decl_init
              | array_conform_decl;

other_var_decls: retain_var_decls
               | no_retain_var_decls
               | loc_partly_var_decl;

no_retain_var_decls: TOK_VAR TOK_NON_RETAIN access_spec_opt var_decl_init_list
                     TOK_END_VAR;

fb_body: sfc
       | ladder_diagram
       | fb_diagram
       | instruction_list
       | stmt_list
       | other_languages;

method_decl: TOK_METHOD access_spec final_abstract_opt override_opt method_name
             method_decl_decl_list func_body TOK_END_METHOD;

override_opt: /* empty */
            | TOK_OVERRIDE;

method_name: simple_identifier;

method_decl_decl_list: /* empty */
                     | method_decl_decl_list method_decl_decl;

method_decl_decl: io_var_decls
                | func_var_decls
                | temp_var_decls;

/* Program declaration, taken from table 47 of the standard */
prog_decl: TOK_PROGRAM prog_type_name prog_decl_decl_list fb_body
           TOK_END_PROGRAM;

prog_decl_decl_list: /* empty */
                   | prog_decl_decl_list prog_decl_decl;

prog_decl_decl: io_var_decls
              | func_var_decls
              | temp_var_decls
              | other_var_decls
              | loc_var_decls
              | prog_access_decls;

prog_type_name: simple_identifier;

prog_type_access: path prog_type_name;

prog_access_decls: TOK_VAR_ACCESS prog_access_decl_list TOK_END_VAR;

prog_access_decl_list: /* empty */
                     | prog_access_decl_list prog_access_decl;

prog_access_decl: access_name ':' symbolic_variable multibit_part_access_opt ':'
                  data_type_access access_direction_opt;

multibit_part_access_opt: /* empty */
                        | multibit_part_access;

access_direction_opt: /* empty */
                    | access_direction;

/* Classes and method calls, taken tables 48 and 50 of the standard */
class_decl: TOK_CLASS final_abstract_opt class_type_name using_directive_list
            class_decl_extends fb_decl_implements class_decl_decl_list
            method_decl_list TOK_END_CLASS;

class_type_name: simple_identifier;

class_decl_extends: /* empty */
                  | TOK_EXTENDS class_type_access;

class_decl_decl_list: /* empty */
                    | class_decl_decl_list class_decl_decl;

class_decl_decl: func_var_decls
               | other_var_decls;

class_type_access: path class_type_name;

class_name: simple_identifier;

class_instance_name: path class_name carret_list_opt;

interface_decl: TOK_INTERFACE interface_type_name using_directive_list
                interface_decl_extends method_prototype_list TOK_END_INTERFACE;

interface_decl_extends: /* empty */
                      | interface_name_list;

method_prototype_list: /* empty */
                     | method_prototype_list method_prototype;

method_prototype: TOK_METHOD method_name method_prototype_access
                  io_var_decls_list TOK_END_METHOD;

method_prototype_access: /* empty */
                       | ':' data_type_access;

io_var_decls_list: /* empty */
                 | io_var_decls_list io_var_decls;

interface_spec_init: variable_list interface_set_value;

interface_set_value: /* empty */
                   | TOK_SET interface_value;

interface_value: symbolic_variable
               | fb_instance_name
               | class_instance_name
               | TOK_NULL;

interface_name_list: interface_type_access
                   | interface_name_list ',' interface_type_access;

interface_type_name: simple_identifier;

interface_type_access: path interface_type_name;

interface_name: simple_identifier;

access_spec: TOK_PUBLIC
           | TOK_PROTECTED
           | TOK_PRIVATE
           | TOK_INTERNAL;

/* Configuration and resources, taken from table 62 of the standard */
config_name: simple_identifier;

resource_type_name: simple_identifier;

config_decl: TOK_CONFIGURATION config_name global_var_decls_opt
             config_decl_resources access_decls_opt config_init_opt
             TOK_END_CONFIGURATION;

global_var_decls_opt: /* empty */
                    | global_var_decls;

config_decl_resources: single_resource_decl
                     | resource_decl_list;

resource_decl_list: resource_decl
                  | resource_decl_list resource_decl;

access_decls_opt: /* empty */
                | access_decls;

config_init_opt: /* empty */
               | config_init;

resource_decl: TOK_RESOURCE resource_name TOK_ON resource_type_name
               global_var_decls_opt single_resource_decl TOK_END_RESOURCE;

single_resource_decl: task_config_list prog_config_list;

task_config_list: /* empty */
                | task_config_list task_config ';';

prog_config_list: prog_config
                | prog_config_list prog_config ';';

resource_name: simple_identifier;

access_decls: TOK_VAR_ACCESS access_decl_list TOK_END_VAR;

access_decl_list: /* empty */
                | access_decl_list access_decl ';';

access_decl: resource_name ':' access_path ':' data_type_access
             access_direction_opt;

access_direction_opt: /* empty */
                    | access_direction;

access_path: resource_path direct_variable
           | resource_path access_path_prog access_path2_list symbolic_variable;

resource_path: /* empty */
             | resource_path resource_name '.';

access_path_prog: /* empty */
                | prog_name '.';

access_path2_list: /* empty */
                 | access_path2_list access_path2 '.';

access_path2: fb_instance_name
            | class_instance_name;

global_var_access: resource_path global_var_name global_var_access_struct;

global_var_access_struct: /* empty */
                        | '.' struct_elem_name;

access_name: simple_identifier;

prog_output_access: prog_name '.' symbolic_variable;

prog_name: simple_identifier;

access_direction: TOK_READ_WRITE
                | TOK_READ_ONLY;

task_config: TOK_TASK task_name task_init;

task_name: simple_identifier;

task_init: '(' task_init_simple task_init_interval task_init_priority ')';

task_init_simple: /* empty */
                | TOK_SINGLE TOK_SET data_source ',';

task_init_interval: /* empty */
                  | TOK_INTERVAL TOK_SET data_source ',';

task_init_priority: TOK_PRIORITY TOK_SET TOK_UNSIGNED_INT_LITERAL;

data_source: constant
           | global_var_access
           | prog_output_access
           | direct_variable;

prog_config: TOK_PROGRAM retain_non_retain_opt prog_name prog_config_with ':'
             prog_type_access prog_config_elems_stuff;

prog_config_with: /* empty */
                | TOK_WITH task_name;

prog_config_elems_stuff: /* EMPTY */
                       | '(' prog_conf_elems ')';

prog_conf_elems: prog_conf_elem
               | prog_conf_elems ',' prog_conf_elem;

prog_conf_elem: fb_task
              | prog_cnxn;

fb_task: fb_instance_name TOK_WITH task_name;

prog_cnxn: symbolic_variable TOK_SET prog_data_source
         | symbolic_variable TOK_FAT_ARROW data_sink;

prog_data_source: constant
                | enum_value
                | global_var_access
                | direct_variable;

data_sink: global_var_access
         | direct_variable;

config_init: TOK_VAR_CONFIG config_inst_init_list TOK_END_VAR;

config_inst_init_list: /* empty */
                     | config_inst_init_list config_inst_init ';';

config_inst_init: resource_name '.' prog_name '.' config_inst_init2_list
                  config_inst_init3;

config_inst_init2_list: /* empty */
                      | config_inst_init2_list config_inst_init2 '.';

config_inst_init2: fb_instance_name
                 | class_instance_name;

config_inst_init3: variable_name located_at_opt ':' loc_var_spec_init
                 | config_inst_init4 TOK_SET struct_init;

config_inst_init4: fb_instance_name ':' fb_type_access
                 | class_instance_name ':' class_type_access;

located_at_opt: /* empty */
              | located_at;

/* Namespaces, taken from table 64 of the standard, finally! */

namespace_decl: TOK_NAMESPACE internal_opt namespace_h_name using_directive_list
                namespace_elements TOK_END_NAMESPACE;

internal_opt: /* empty */
            | TOK_INTERNAL;

namespace_elements: namespace_element
                  | namespace_elements namespace_element;

namespace_element: data_type_decl
                 | func_decl
                 | fb_decl
                 | class_decl
                 | interface_decl
                 | namespace_decl;

namespace_h_name: namespace_name
                | namespace_h_name '.' namespace_name;

namespace_name: simple_identifier;

using_directive: TOK_USING namespace_h_name_list ';';

namespace_h_name_list: namespace_h_name
                     | namespace_h_name_list ',' namespace_h_name;

POU_decl: using_directive_list POU_decl2_list;

POU_decl2_list: POU_decl2
              | POU_decl2_list POU_decl2;

POU_decl2: global_var_decls
         | data_type_decl
         | access_decls
         | func_decl
         | fb_decl
         | class_decl
         | interface_decl
         | namespace_decl;























/******************************************************************************/

/* Placeholders! TODO! */
ladder_diagram: TOK_LANG_LD;
fb_diagram: TOK_LANG_FB;
instruction_list: TOK_LANG_IL;
stmt_list: TOK_LANG_ST;
sfc: TOK_LANG_SFC;
other_languages: TOK_LANG_C;

/* constant_expr: TOK_TODO; */
expression: TOK_TODO
          | constant_expr;

multibit_part_access: TOK_TODO;

/******************************************************************************/
/*                    Structured Text Programming Language                    */
/******************************************************************************/
constant_expr: constant_expr TOK_OR constant_expr {
               $$ = [$1 or: $3];
             }
             | constant_expr TOK_XOR constant_expr {
               $$ = [$1 xor: $3];
             }
             | constant_expr TOK_AND constant_expr {
               $$ = [$1 and: $3];
             }
             | constant_expr TOK_EQUAL constant_expr {
               $$ = [$1 equal: $3];
             }
             | constant_expr TOK_DIFF constant_expr {
               $$ = [$1 different: $3];
             }
             | constant_expr TOK_LESS constant_expr {
               $$ = [$1 less_than: $3];
             }
             | constant_expr TOK_MORE constant_expr {
               $$ = [$1 more_than: $3];
             }
             | constant_expr TOK_LESS_EQ constant_expr {
               $$ = [$1 less_eq_than: $3];
             }
             | constant_expr TOK_MORE_EQ constant_expr {
               $$ = [$1 more_eq_than: $3];
             }
             | constant_expr TOK_PLUS constant_expr {
               $$ = [$1 add: $3];
             }
             | constant_expr TOK_MINUS constant_expr {
               $$ = [$1 sub: $3];
             }
             | constant_expr TOK_TIMES constant_expr {
               $$ = [$1 mul: $3];
             }
             | constant_expr TOK_DIV constant_expr {
               $$ = [$1 div: $3];
             }
             | constant_expr TOK_MOD constant_expr {
               $$ = [$1 mod: $3];
             }
             | constant_expr TOK_POWER constant_expr {
               $$ = [$1 pow: $3];
             }
             | TOK_MINUS constant_expr %prec TOK_UNARY_MINUS {
               $$ = [$2 minus];
             }
             | TOK_PLUS constant_expr %prec TOK_UNARY_PLUS {
               $$ = $2;
             }
             | TOK_NOT constant_expr {
               $$ = [$2 not];
             }
             | '(' constant_expr ')' {
               $$ = $2;
             }
             | numeric_literal {
               $$ = $1;
             };

/******************************************************************************/
/*                    Instruction List Programming Language                   */
/******************************************************************************/


/******************************************************************************/
/*                     Ladder Diagram Programming Language                    */
/******************************************************************************/


/******************************************************************************/
/*                 Function Block Diagram Programming Language                */
/******************************************************************************/


/******************************************************************************/
/*                Sequential Function Chart Programming Language              */
/******************************************************************************/


/******************************************************************************/
/*                           C Programming Language                           */
/******************************************************************************/


%%

/**
 * Temporary main function. Just lexes stdin and show which
 * tokens were found. :)
 */
int main(int argc, char **argv) {
  
  @autoreleasepool {
    
    yydebug = argv[1] && strcmp(argv[1], "debug") == 0;
    
    IECCBinder *binder = IECCBinder.new;
    //~ @try {
      
      yyparse(binder);
      [binder autorelease];
      
    //~ } @catch(id exception) {
      //~ assert("Internal compiler error." && !"Unexpected exception.");
    //~ };
  };
  
  return EXIT_SUCCESS;
  
  /*int x;
  extern int yyleng;
  extern int yylineno;
  extern int yycolumn;
  extern char *yytext;
  
  do {
    x = yylex();
    printf("%d:%02d-%02d:", yylineno, yycolumn, yycolumn + x ? yyleng : 0);
    if(x >= 0x80) {
      printf("%-26s %s", yytname[x - 255], yytext);
    } else {
      if(x) {
        printf("'%c'", x);
      } else {
        printf("EOF");
      };
    };
    printf("\n");
  } while(x);*/
  
  return EXIT_SUCCESS;
};
