/*******************************************************************************
* Project: IECC (IEC 61131-3 Languages Compiler for Arduino).                  *
* Authors: Paulo H. Torrens <paulotorrens AT gnu DOT org>.                     *
* License: GNU GPLv3+.                                                         *
*                                                                              *
* Language: Bison -> (Modern) Objective-C.                                     *
* Description: Compiler parser file. It handles the grammar of the common base *
*   and of all the programming languages supported.                            *
********************************************************************************
* Copyright (C) 2015 - Paulo H. Torrens. All rights reserved.                  *
*                                                                              *
* This program is free software: you can redistribute it and/or modify it      *
* under the terms of the GNU General Public License as published by the Free   *
* Software Foundation, either version 3 of the License, or (at your option)    *
* any later version.                                                           *
*                                                                              *
* This program is distributed in the hope that it will be useful, but WITHOUT  *
* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or        *
* FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for     *
* more details.                                                                *
*                                                                              *
* You should have received a copy of the GNU General Public License along with *
* this program. If not, see <http://www.gnu.org/licenses/>.                    *
*******************************************************************************/
/*
  RATIONALE:
  
  I've tried to keep note of every part of the standard where I find each piece,
  so anyone can easely look into it if necessary, but (please don't get mad, IEC
  guys) it's quite hard and it's a bit messy. This parser makes a lot of type
  dependent lookups, which means we have to keep giving back information to the
  lexer all the time (e.g., as soon as a type or a variable is about to be
  defined), the good ol' "The Lexer Hack". So you will need to carefully need
  study the lexer too to understand this. If you have a copy of the standard
  you'll notice that I had to change a lot of tokens to get the correct
  behaviour without any ambiguities, typechecking it during parsing.
  
  So, if you find the grammar confusing, don't blame me! :(
*/
%{
  //
  #import <stdlib.h>
  #import <stdio.h>
  
  //
  extern int yylex(void);
  
  //
  void yyerror(char const *str) {
    /* TODO */
  };
%}

%locations
%token-table
%error-verbose

/* Helper */
%token TOK_TODO
%token TOK_INVALID

/* Operators */
%token TOK_SET
%token TOK_DOTDOT

/* Table 2 */
%token TOK_IDENTIFIER
%token TOK_QUALIFIED_IDENTIFIER

/* Table 4 */
%token TOK_PRAGMA

/* Table 5 */
%token TOK_SIGNED_INT_LITERAL
%token TOK_UNSIGNED_INT_LITERAL
%token TOK_GENERIC_INT_LITERAL
%token TOK_REAL_LITERAL
%token TOK_BIT_STR_LITERAL
%token TOK_BOOL_LITERAL

/* Table 6 */
%token TOK_TYPED_CHAR_LITERAL
%token TOK_UNTYPED_CHAR_LITERAL_S
%token TOK_UNTYPED_CHAR_LITERAL_D

/* Tables 8 and 9 */
%token TOK_TIME_LITERAL;

/* Table 10 */
%token TOK_SINT
%token TOK_INT
%token TOK_DINT
%token TOK_LINT
%token TOK_USINT
%token TOK_UINT
%token TOK_UDINT
%token TOK_ULINT
%token TOK_REAL
%token TOK_LREAL
%token TOK_BOOL
%token TOK_BYTE
%token TOK_WORD
%token TOK_DWORD
%token TOK_LWORD
%token TOK_STRING
%token TOK_WSTRING
%token TOK_CHAR
%token TOK_WCHAR
%token TOK_DATE
%token TOK_LDATE
%token TOK_TIME
%token TOK_LTIME
%token TOK_TOD
%token TOK_LTOD
%token TOK_DT
%token TOK_LDT

/* Table 11 */
%token TOK_SIMPLE_TYPENAME
%token TOK_SUBRANGE_TYPENAME
%token TOK_ENUM_TYPENAME
%token TOK_ARRAY_TYPENAME
%token TOK_STRUCT_TYPENAME
%token TOK_STRING_TYPENAME
%token TOK_CLASS_TYPENAME
%token TOK_REF_TYPENAME
%token TOK_INTERFACE_TYPENAME
%token TOK_ENUM_LITERAL
%token TOK_TYPE
%token TOK_END_TYPE
%token TOK_ARRAY
%token TOK_OF
%token TOK_STRUCT
%token TOK_END_STRUCT
%token TOK_OVERLAP

/* Table 12 */
%token TOK_REF_TO
%token TOK_REF
%token TOK_NULL

/* Tables 13 and 14 */
%token TOK_THIS
%token TOK_VAR
%token TOK_VAR_INPUT
%token TOK_VAR_OUTPUT
%token TOK_VAR_IN_OUT
%token TOK_VAR_TEMP
%token TOK_VAR_EXTERNAL
%token TOK_VAR_GLOBAL
%token TOK_RETAIN
%token TOK_NON_RETAIN
%token TOK_END_VAR
%token TOK_R_EDGE
%token TOK_F_EDGE
%token TOK_CONSTANT
%token TOK_AT

/* Table 16 */
%token TOK_DIRECT_VARIABLE
%token TOK_DIRECT_VARIABLE_PART;

/* Table 19 */
%token TOK_FUNCTION
%token TOK_END_FUNCTION

/* Tables 40 and 41 */
%token TOK_FUNCTION_BLOCK
%token TOK_END_FUNCTION_BLOCK
%token TOK_FINAL
%token TOK_ABSTRACT
%token TOK_EXTENDS
%token TOK_IMPLEMENTS
%token TOK_METHOD
%token TOK_END_METHOD
%token TOK_OVERRIDE

/* Tables 48 and 50 */
%token TOK_CLASS
%token TOK_END_CLASS
%token TOK_INTERFACE
%token TOK_END_INTERFACE
%token TOK_PUBLIC
%token TOK_PROTECTED
%token TOK_PRIVATE
%token TOK_INTERNAL

/* Placeholders! TODO! */
%token TOK_LANG_LD
%token TOK_LANG_FB
%token TOK_LANG_IL
%token TOK_LANG_ST
%token TOK_LANG_SFC
%token TOK_LANG_C

/******************************************************************************/
%%
/*

*/
translation_unit: POU_decl;

/* Identifier, taken from table 2 of the standard */
simple_identifier: TOK_IDENTIFIER
                 /* Taken from table 10 */
                 | TOK_SIMPLE_TYPENAME
                 | TOK_SUBRANGE_TYPENAME
                 | TOK_ENUM_TYPENAME
                 | TOK_ARRAY_TYPENAME
                 | TOK_STRUCT_TYPENAME
                 | TOK_STRING_TYPENAME
                 | TOK_CLASS_TYPENAME
                 | TOK_REF_TYPENAME
                 | TOK_INTERFACE_TYPENAME;

qualified_identifier: path simple_identifier;

path: /* empty */
    | path simple_identifier '.';

/* Numeric literals, taken from table 5 of the standard */
constant: numeric_literal
        | char_literal
        | time_literal
        | bit_str_literal
        | bool_literal;

numeric_literal: int_literal
               | real_literal;

int_literal: TOK_SIGNED_INT_LITERAL
           | TOK_UNSIGNED_INT_LITERAL
           | TOK_GENERIC_INT_LITERAL;

real_literal: TOK_REAL_LITERAL;

bit_str_literal: TOK_BIT_STR_LITERAL;

bool_literal: TOK_BOOL_LITERAL;

/* Character string literals, taken from table 6 of the standard */
char_literal: char_str
            | TOK_TYPED_CHAR_LITERAL;

s_byte_char_str: TOK_UNTYPED_CHAR_LITERAL_S;

d_byte_char_str: TOK_UNTYPED_CHAR_LITERAL_D;

char_str: s_byte_char_str
        | d_byte_char_str;

/* Duration, data and time of day literals, taken from tables 8 and 9 of... */
time_literal: TOK_TIME_LITERAL;

/* Elementary data types, taken from table 10 of the standard */
data_type_access: elem_type_name
                | derived_type_access;

elem_type_name: numeric_type_name
              | bit_str_type_name
              | string_type_name
              | date_type_name
              | time_type_name
              | tod_type_name /* (For now) I believe that the standard */
              | dt_type_name; /* forgot to add these rules here... =/  */

elem_type_name_opt: /* empty */
                  | elem_type_name;

numeric_type_name: int_type_name
                 | real_type_name;

int_type_name: sign_int_type_name
             | unsign_int_type_name;

sign_int_type_name: TOK_SINT
                  | TOK_INT
                  | TOK_DINT
                  | TOK_LINT;

unsign_int_type_name: TOK_USINT
                    | TOK_UINT
                    | TOK_UDINT
                    | TOK_ULINT;

real_type_name: TOK_REAL
              | TOK_LREAL;

bit_str_type_name: TOK_BOOL
                 | TOK_BYTE
                 | TOK_WORD
                 | TOK_DWORD
                 | TOK_LWORD;

string_type_name: TOK_STRING string_size
                | TOK_WSTRING string_size
                | TOK_CHAR
                | TOK_WCHAR;

string_size: /* empty */
           | '[' TOK_UNSIGNED_INT_LITERAL ']';

date_type_name: TOK_DATE
              | TOK_LDATE;

time_type_name: TOK_TIME
              | TOK_LTIME;

tod_type_name: TOK_TOD
             | TOK_LTOD;

dt_type_name: TOK_DT
            | TOK_LDT

/* User data types, taken from table 11 of the standard */
derived_type_access: single_elem_type_access
                   | array_type_access
                   | struct_type_access
                   | string_type_access
                   | class_type_access
                   | ref_type_access
                   | interface_type_access;

single_elem_type_access: simple_type_access
                       | subrange_type_access
                       | enum_type_access;

simple_type_access: TOK_SIMPLE_TYPENAME;

subrange_type_access: TOK_SUBRANGE_TYPENAME;

enum_type_access: TOK_ENUM_TYPENAME;

array_type_access: TOK_ARRAY_TYPENAME;

struct_type_access: TOK_STRUCT_TYPENAME;

string_type_access: TOK_STRING_TYPENAME;

class_type_access: TOK_CLASS_TYPENAME;

ref_type_access: TOK_REF_TYPENAME;

interface_type_access: TOK_INTERFACE_TYPENAME;

data_type_decl: TOK_TYPE type_decl_list TOK_END_TYPE;

type_decl_list: type_decl ";"
              | type_decl_list type_decl ";";

type_decl: simple_type_decl
         | subrange_type_decl
         | enum_type_decl
         | array_type_decl
         | struct_type_decl
         | str_type_decl
         | ref_type_decl;

simple_type_decl: simple_identifier ':' simple_spec_init;

simple_spec_init: simple_spec simple_set_value;

simple_spec: elem_type_name
           | simple_type_access;

simple_set_value: /* empty */
                | TOK_SET constant_expr;

subrange_type_decl: simple_identifier ':' subrange_spec_init;

subrange_spec_init: subrange_spec subrange_set_value;

subrange_spec: int_type_name '(' subrange ')'
             | subrange_type_access;

subrange: constant_expr TOK_DOTDOT constant_expr;

subrange_set_value: /* empty */
                  | TOK_SET TOK_SIGNED_INT_LITERAL;

enum_type_decl: simple_identifier ':' enum_type_decl2;

enum_type_decl2: elem_type_name_opt named_spec_init
               | enum_spec_init;

named_spec_init: '(' enum_value_spec_list ')' named_set_value;

named_set_value: /* empty */
               | TOK_SET enum_value;

enum_value_spec_list: enum_value_spec
                    | enum_value_spec_list ',' enum_value_spec;

enum_spec_init: enum_spec_init_type named_set_value;

enum_spec_init_type: '(' enum_value_spec_list ')'
                   | enum_type_access;

enum_value_spec: simple_identifier enum_value_spec_set_value;

enum_value_spec_set_value: /* empty */
                         | TOK_SET int_literal
                         | TOK_SET constant_expr;

enum_value: simple_identifier
          | TOK_ENUM_LITERAL;

array_type_decl: simple_identifier ':' array_spec_init;

array_spec_init: array_spec array_set_value;

array_set_value: /* empty */
               | TOK_SET array_init;

array_spec: array_type_access
          | TOK_ARRAY '[' subrange_list ']' TOK_OF data_type_access;

subrange_list: subrange
             | subrange_list ',' subrange;

array_init: '[' array_elem_init_list ']';

array_elem_init_list: array_elem_init
                    | array_elem_init_list ',' array_elem_init;

array_elem_init: array_elem_init_value
               | TOK_UNSIGNED_INT_LITERAL '(' array_elem_init_value_opt ')';

array_elem_init_value: constant_expr
                     | enum_value
                     | struct_init
                     | array_init;

array_elem_init_value_opt: /* empty */
                         | array_elem_init_value;

struct_type_decl: simple_identifier ':' struct_spec;

struct_spec: struct_decl
           | struct_spec_init;

struct_spec_init: struct_type_access struct_set_value;

struct_set_value: /* empty */
                | TOK_SET struct_init;

struct_decl: TOK_STRUCT struct_elem_decl_list TOK_END_STRUCT
           | TOK_STRUCT TOK_OVERLAP struct_elem_decl_list TOK_END_STRUCT;

struct_elem_decl_list: struct_elem_decl ';'
                     | struct_elem_decl_list struct_elem_decl ';';

struct_elem_decl: struct_elem_decl2 ':' struct_elem_decl3;

struct_elem_decl2: simple_identifier
                 | simple_identifier located_at
                 | simple_identifier located_at multibit_part_access;

struct_elem_decl3: simple_spec_init
                 | subrange_spec_init
                 | enum_spec_init
                 | array_spec_init
                 | struct_spec_init;

struct_init: '(' struct_elem_init_list ')';

struct_elem_init_list: struct_elem_init
                     | struct_elem_init_list ',' struct_elem_init;

struct_elem_init: simple_identifier struct_elem_set_value;

struct_elem_set_value: TOK_SET constant_expr
                     | TOK_SET enum_value
                     | TOK_SET array_init
                     | TOK_SET struct_init
                     | TOK_SET ref_value;

str_type_decl: simple_identifier ':' string_type_name string_set_value;

string_set_value: /* empty */
                | TOK_SET char_str;

/* References, taken from table 12 of the standard */
ref_type_decl: simple_identifier ':' ref_spec_init;

ref_spec_init: ref_spec ref_set_value;

ref_set_value: /* empty */
             | TOK_SET ref_value;

ref_spec: ref_to_list data_type_access;

ref_to_list: TOK_REF_TO
           | ref_to_list TOK_REF_TO;

ref_value: ref_addr
         | TOK_NULL;

ref_addr: TOK_REF '(' ref_addr2 ')';

ref_addr2: symbolic_variable
         | fb_instance_name
         | class_instance_name;

/* oh God... :( */

ref_assign: simple_identifier TOK_SET simple_identifier
          | simple_identifier TOK_SET ref_deref
          | ref_value;

ref_deref: simple_identifier carret_list;

carret_list: '^'
           | carret_list '^';

carret_list_opt: /* empty */
               | carret_list;

/* Declaration and initialization of variables, taken from tables 13 and 14 */
variable: direct_variable
        | symbolic_variable;

symbolic_variable: symbolic_variable_path symbolic_variable_access;

symbolic_variable_access: var_access
                        | multi_elem_var;

symbolic_variable_path: /* empty */
                      | TOK_THIS '.'
                      | path;

var_access: simple_identifier /* oh God... :( */
          | ref_deref;

multi_elem_var: var_access multi_elem_var2_list;

multi_elem_var2_list: multi_elem_var2
                    | multi_elem_var2_list multi_elem_var2;

multi_elem_var2: subscript_list
               | struct_variable;

subscript_list: '[' subscript_list2 ']';

subscript_list2: subscript
               | subscript_list2 ',' subscript;

subscript: expression;

struct_variable: '.' struct_elem_select;

struct_elem_select: var_access; /* WHY, IEC, WHY?!?! */

input_decls: TOK_VAR_INPUT retain_non_retain_opt input_decl_list TOK_END_VAR;

retain_non_retain: TOK_RETAIN
                 | TOK_NON_RETAIN;

retain_non_retain_opt: /* empty */
                     | retain_non_retain;

input_decl_list: /* empty */
               | input_decl_list input_decl ';';

input_decl: var_decl_init
          | edge_decl
          | array_conform_decl;

edge_decl: variable_list ':' TOK_BOOL TOK_R_EDGE
         | variable_list ':' TOK_BOOL TOK_F_EDGE;
         
variable_list: variable_name
             | variable_list ',' variable_name;

variable_name: simple_identifier;

var_decl_init: variable_list ':' var_decl_init2
             | array_var_decl_init
             | struct_var_decl_init
             | fb_decl_init
             | interface_spec_init;

var_decl_init2: simple_spec_init
              | str_var_decl
              | ref_spec_init;

ref_var_decl: variable_list ':' ref_spec;

interface_var_decl: variable_list ':' interface_type_access;

array_var_decl_init: variable_list ':' array_spec_init;

array_conformand: TOK_ARRAY '[' star_list ']' TOK_OF data_type_access;

star_list: '*'
         | star_list ',' '*';

star_list_opt: /* empty */
             | star_list;

array_conform_decl: variable_list ':' array_conformand;

struct_var_decl_init: variable_list ':' struct_spec_init;

fb_decl_no_init: fb_name_list ':' fb_type_access;

fb_name_list: simple_identifier
            | fb_name_list ',' simple_identifier;

fb_decl_init: fb_decl_no_init fb_decl_set_value;

fb_decl_set_value: /* empty */
                 | TOK_SET struct_init;

fb_instance_name: path fb_name carret_list_opt;

fb_name: simple_identifier;

output_decls: TOK_VAR_OUTPUT retain_non_retain_opt output_decl_list TOK_END_VAR;

output_decl_list: /* empty */
                | output_decl_list output_decl ';';

output_decl: var_decl_init
           | array_conform_decl;

in_out_decls: TOK_VAR_IN_OUT in_out_var_decl_list TOK_END_VAR;

in_out_var_decl_list: /* empty */
                    | in_out_var_decl_list in_out_var_decl ';';

in_out_var_decl: var_decl
               | array_conform_decl
               | fb_decl_no_init;

var_decl: variable_list ':' var_decl2;

var_decl2: simple_spec
         | str_var_decl
         | array_var_decl
         | struct_var_decl;

array_var_decl: variable_list ':' array_spec;

struct_var_decl: variable_list ':' struct_type_access;

var_decls: TOK_VAR constant_opt access_spec_opt var_decl_init_list TOK_END_VAR;

constant_opt: /* empty */
            | TOK_CONSTANT;

access_spec_opt: /* empty */
               | access_spec;

var_decl_init_list: /* empty */
                  | var_decl_init_list var_decl_init ';';

retain_var_decls: TOK_VAR TOK_RETAIN access_spec_opt var_decl_init_list
                  TOK_END_VAR;

loc_var_decls: TOK_VAR constant_retain_non_retain_opt loc_var_decl_list
               TOK_END_VAR;

constant_retain_non_retain_opt: TOK_CONSTANT
                              | retain_non_retain_opt;

loc_var_decl_list: /* empty */
                 | loc_var_decl_list loc_var_decl ';';

loc_var_decl: variable_name_opt located_at ':' loc_var_spec_init;

variable_name_opt: /* empty */
                 | variable_name;

temp_var_decls: TOK_VAR_TEMP temp_var_decls2_list TOK_END_VAR;

temp_var_decls2_list: /* empty */
                    | temp_var_decls2_list temp_var_decls2 ';';

temp_var_decls2: var_decl
               | ref_var_decl
               | interface_var_decl;

external_var_decls: TOK_VAR_EXTERNAL constant_opt external_decl_list
                    TOK_END_VAR;

external_decl_list: /* empty */
                  | external_decl_list external_decl ';';

external_decl: global_var_name ':' external_decl2;

external_decl2: simple_spec
              | array_spec
              | struct_type_access
              | fb_type_access
              | ref_type_access;

global_var_name: simple_identifier;

global_var_decls: TOK_VAR_GLOBAL constant_retain_opt global_var_decl_list
                  TOK_END_VAR;

constant_retain_opt: /* empty */
                   | TOK_CONSTANT
                   | TOK_RETAIN;

global_var_decl_list: /* empty */
                    | global_var_decl_list global_var_decl ';';

global_var_decl: global_var_spec ':' global_var_decl2;

global_var_decl2: loc_var_spec_init
                | fb_type_access;

global_var_spec: global_var_spec2
               | global_var_spec3;

global_var_spec2: global_var_name_list;

global_var_name_list: global_var_name
                    | global_var_name_list ',' global_var_name;

global_var_spec3: global_var_name located_at;

loc_var_spec_init: simple_spec_init
                 | array_spec_init
                 | struct_spec_init
                 | s_byte_str_spec
                 | d_byte_str_spec;

located_at: TOK_AT direct_variable;

str_var_decl: s_byte_str_var_decl
            | d_byte_str_var_decl;

s_byte_str_var_decl: variable_list ':' s_byte_str_spec;

s_byte_str_spec: TOK_STRING string_size s_byte_str_set_value;

s_byte_str_set_value: /* empty */
                    | TOK_SET s_byte_char_str;

d_byte_str_var_decl: variable_list ':' d_byte_str_spec;

d_byte_str_spec: TOK_WSTRING string_size d_byte_str_set_value;

d_byte_str_set_value: /* empty */
                    | TOK_SET d_byte_char_str;

loc_partly_var_decl: TOK_VAR retain_non_retain_opt loc_partly_var_list

loc_partly_var_list: /* empty */
                   | loc_partly_var_list loc_partly_var;

loc_partly_var: variable_name TOK_AT TOK_DIRECT_VARIABLE_PART ':' var_spec ';';

var_spec: simple_spec
        | array_spec
        | struct_type_access
        | var_spec_str_spec;

var_spec_str_spec: TOK_STRING string_size
                 | TOK_WSTRING string_size;

/* Directly represented variables, taken from table 16 of the standard */
direct_variable: TOK_DIRECT_VARIABLE
               | TOK_DIRECT_VARIABLE_PART;

/* Function declarations, taken from table 19 of the standard */
func_name: std_func_name
         | derived_func_name;

func_access: path func_name;

std_func_name: TOK_TODO;

derived_func_name: simple_identifier;

func_decl: TOK_FUNCTION derived_func_name func_data_type_access
           using_directive_list func_decl_var_decl_list func_body
           TOK_END_FUNCTION;

func_data_type_access: /* empty */
                     | ':' data_type_access;

using_directive_list: /* empty */
                    | using_directive_list using_directive;

func_decl_var_decl_list: /* empty */
                       | func_decl_var_decl_list func_decl_var_decl;

func_decl_var_decl: io_var_decls
                  | func_var_decls
                  | temp_var_decls;

io_var_decls: input_decls
            | output_decls
            | in_out_decls;

func_var_decls: external_var_decls
              | var_decls;

func_body: ladder_diagram
         | fb_diagram
         | instruction_list
         | stmt_list
         | other_languages;

/* Function block type and instance declarations, taken from tables 40 and 41 */
fb_type_name: std_fb_name
            | derived_fb_name;

fb_type_access: path fb_type_name;

std_fb_name: TOK_TODO;

derived_fb_name: simple_identifier;

fb_decl: TOK_FUNCTION_BLOCK final_abstract_opt derived_fb_name
         using_directive_list fb_decl_extends fb_decl_implements
         fb_decl_decl_list method_decl_list fb_body_opt TOK_END_FUNCTION_BLOCK;

fb_body_opt: /* empty */
           | fb_body;

method_decl_list: /* empty */
                | method_decl_list method_decl;

final_abstract_opt: /* empty */
                  | TOK_FINAL
                  | TOK_ABSTRACT;

fb_decl_extends: /* empty */
               | TOK_EXTENDS fb_type_access
               | TOK_EXTENDS class_type_access;

fb_decl_implements: /* empty */
                  | TOK_IMPLEMENTS interface_name_list;

fb_decl_decl_list: /* empty */
                 | fb_decl_decl_list fb_decl_decl;

fb_decl_decl: fb_io_var_decls
            | func_var_decls
            | temp_var_decls
            | other_var_decls;

fb_io_var_decls: fb_input_decls
               | fb_output_decls
               | in_out_decls;

fb_input_decls: TOK_VAR_INPUT retain_non_retain_opt fb_input_decl_list
                TOK_END_VAR;

fb_input_decl_list: /* empty */
                  | fb_input_decl_list fb_input_decl ';';

fb_input_decl: var_decl_init
             | edge_decl
             | array_conform_decl;

fb_output_decls: TOK_VAR_OUTPUT retain_non_retain_opt fb_output_decl_list
                 TOK_END_VAR;

fb_output_decl_list: /* empty */
                   | fb_output_decl_list fb_output_decl ';';

fb_output_decl: var_decl_init
              | array_conform_decl;

other_var_decls: retain_var_decls
               | no_retain_var_decls
               | loc_partly_var_decl;

no_retain_var_decls: TOK_VAR TOK_NON_RETAIN access_spec_opt var_decl_init_list
                     TOK_END_VAR;

fb_body: sfc
       | ladder_diagram
       | fb_diagram
       | instruction_list
       | stmt_list
       | other_languages;

method_decl: TOK_METHOD access_spec final_abstract_opt override_opt method_name
             method_decl_decl_list func_body TOK_END_METHOD;

override_opt: /* empty */
            | TOK_OVERRIDE;

method_name: simple_identifier;

method_decl_decl_list: /* empty */
                     | method_decl_decl_list method_decl_decl;

method_decl_decl: io_var_decls
                | func_var_decls
                | temp_var_decls;

/* Classes and method calls, taken tables 48 and 50 of the standard */
class_decl: TOK_CLASS final_abstract_opt class_type_name using_directive_list
            class_decl_extends fb_decl_implements class_decl_decl_list
            method_decl_list TOK_END_CLASS;

class_type_name: simple_identifier;

class_decl_extends: /* empty */
                  | TOK_EXTENDS class_type_access;

class_decl_decl_list: /* empty */
                    | class_decl_decl_list class_decl_decl;

class_decl_decl: func_var_decls
               | other_var_decls;

class_type_name: simple_identifier;

class_type_access: path class_type_name;

class_name: simple_identifier;

class_instance_name: path class_name carret_list_opt;

interface_decl: TOK_INTERFACE interface_type_name using_directive_list
                interface_decl_extends method_prototype_list TOK_END_INTERFACE;

interface_decl_extends: /* empty */
                      | interface_name_list;

method_prototype_list: /* empty */
                     | method_prototype_list method_prototype;

method_prototype: TOK_METHOD method_name method_prototype_access
                  io_var_decls_list TOK_END_METHOD;

method_prototype_access: /* empty */
                       | ':' data_type_access;

io_var_decls_list: /* empty */
                 | io_var_decls_list io_var_decls;

interface_spec_init: variable_list interface_set_value;

interface_set_value: /* empty */
                   | TOK_SET interface_value;

interface_value: symbolic_variable
               | fb_instance_name
               | class_instance_name
               | TOK_NULL;

interface_name_list: interface_type_access
                   | interface_name_list ',' interface_type_access;

interface_type_name: simple_identifier;

interface_type_access: path interface_type_name;

interface_name: simple_identifier;

access_spec: TOK_PUBLIC
           | TOK_PROTECTED
           | TOK_PRIVATE
           | TOK_INTERNAL;

























/* Placeholders! TODO! */
ladder_diagram: TOK_LANG_LD;
fb_diagram: TOK_LANG_FB;
instruction_list: TOK_LANG_IL;
stmt_list: TOK_LANG_ST;
sfc: TOK_LANG_SFC;
other_languages: TOK_LANG_C;

%%

/**
 * Temporary main function. Just lexes stdin and show which
 * tokens were found. :)
 */
int main() {
  int x;
  extern int yyleng;
  extern int yylineno;
  extern int yycolumn;
  extern char *yytext;
  
  do {
    x = yylex();
    printf("%d:%02d-%02d:", yylineno, yycolumn, yycolumn + x ? yyleng : 0);
    if(x >= 0x80) {
      printf("%-20s %s", yytname[x - 255], yytext);
    } else {
      if(x) {
        printf("'%c'", x);
      } else {
        printf("EOF");
      };
    };
    printf("\n");
  } while(x);
  
  return EXIT_SUCCESS;
};
